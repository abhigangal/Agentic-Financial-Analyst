import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';
import { StockAnalysis, EsgAnalysis, MacroAnalysis, MarketIntelligenceAnalysis, LeadershipAnalysis, GroundingSource, RiskAnalysis, CompetitiveAnalysis, SectorAnalysis, CorporateCalendarAnalysis, CalculatedMetric, ChiefAnalystCritique, FinancialMetrics, TechnicalAnalysis, ContrarianAnalysis, ExecutiveProfile, ExecutionStep, QuantitativeAnalysis } from '../types';

// --- Color and Font Definitions for a Professional Theme ---
const COLORS = {
    HEADER_BG: '#1E293B', // slate-800
    HEADER_TEXT: '#FFFFFF',
    PRIMARY_TEXT: '#0F172A', // slate-900
    SECONDARY_TEXT: '#64748B', // slate-500
    ACCENT_BLUE: '#2563EB', // blue-600
    BORDER_LIGHT: '#E2E8F0', // slate-200
    CODE_BG: '#F1F5F9', // slate-100
    WHITE: '#FFFFFF',
    RED: '#DC2626', // red-600
    GREEN: '#16A34A', // green-600
    YELLOW: '#CA8A04', // yellow-600
    ORANGE: '#EA580C', // orange-600
};

const FONT_SIZES = {
    H1: 22,
    H2: 16,
    H3: 12,
    BODY: 10,
    SMALL: 8
};

const getFilenameTimestamp = (): string => {
    const d = new Date();
    const pad = (n: number) => n.toString().padStart(2, '0');
    return `${d.getFullYear()}${pad(d.getMonth() + 1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}`;
}

const formatPrice = (price: number | null, currencySymbol: string): string => {
    if (price === null || isNaN(price)) return 'N/A';
    const symbolToShow = currencySymbol === '₹' ? 'Rs. ' : currencySymbol;
    return `${symbolToShow}${price.toFixed(2)}`;
};

const getMetricValue = (metric: CalculatedMetric | number | string | null): string => {
    if (metric === null || metric === undefined) return 'N/A';
    if (typeof metric === 'string') {
        const num = parseFloat(metric.replace(/[^0-9.-]/g, ''));
        return isNaN(num) ? metric : num.toFixed(2);
    }
    if (typeof metric === 'number') return metric.toFixed(2);
    if (metric && typeof metric === 'object' && 'value' in metric) {
        return metric.value !== null ? metric.value.toFixed(2) : 'N/A';
    }
    return 'N/A';
};

class PdfBuilder {
  private doc: jsPDF;
  private y: number;
  private readonly pageHeight: number;
  private readonly pageWidth: number;
  private readonly margin: number = 30;
  private readonly contentWidth: number;
  private headerTitle: string = '';

  constructor(title: string) {
    this.doc = new jsPDF({ orientation: 'p', unit: 'pt', format: 'a4' });
    this.pageHeight = this.doc.internal.pageSize.getHeight();
    this.pageWidth = this.doc.internal.pageSize.getWidth();
    this.contentWidth = this.pageWidth - this.margin * 2;
    this.y = this.margin;
    this.headerTitle = title;
  }
  
  private addPageIfNeeded(requiredHeight: number) {
    if (this.y + requiredHeight > this.pageHeight - this.margin) {
      this.doc.addPage();
      this.y = this.margin + 20;
    }
  }

  private addHeadersAndFooters() {
      const pageCount = (this.doc as any).internal.getNumberOfPages();
      for (let i = 1; i <= pageCount; i++) {
          this.doc.setPage(i);
          
          this.doc.setFontSize(FONT_SIZES.SMALL);
          this.doc.setFont('helvetica', 'bold');
          this.doc.setTextColor(COLORS.SECONDARY_TEXT);
          this.doc.text(this.headerTitle, this.margin, this.margin - 15);
          this.doc.setDrawColor(COLORS.BORDER_LIGHT);
          this.doc.line(this.margin, this.margin - 5, this.pageWidth - this.margin, this.margin - 5);
          
          const pageStr = `Page ${i} of ${pageCount}`;
          this.doc.setDrawColor(COLORS.BORDER_LIGHT);
          this.doc.line(this.margin, this.pageHeight - this.margin, this.pageWidth - this.margin, this.pageHeight - this.margin);
          this.doc.setTextColor(COLORS.SECONDARY_TEXT);
          this.doc.text(pageStr, this.pageWidth - this.margin - this.doc.getTextWidth(pageStr), this.pageHeight - this.margin + 15);
          this.doc.text('AG Generated by Agentic Financial Analyst', this.margin, this.pageHeight - this.margin + 15);
      }
  }

  buildTitlePage(mainTitle: string, subTitle: string) {
    this.y = this.pageHeight / 3;
    
    this.doc.setFontSize(32);
    this.doc.setFont('helvetica', 'bold');
    this.doc.setTextColor(COLORS.PRIMARY_TEXT);
    this.doc.text(mainTitle, this.pageWidth / 2, this.y, { align: 'center' });
    this.y += 40;

    this.doc.setFontSize(18);
    this.doc.setFont('helvetica', 'normal');
    this.doc.setTextColor(COLORS.SECONDARY_TEXT);
    this.doc.text(subTitle, this.pageWidth / 2, this.y, { align: 'center' });
    this.y += 80;
    
    this.doc.setFontSize(FONT_SIZES.BODY);
    this.doc.text(`Generated on: ${new Date().toLocaleDateString('en-GB', { day: '2-digit', month: 'short', year: 'numeric' })}`, this.pageWidth / 2, this.y, { align: 'center' });
    
    this.doc.addPage();
    this.y = this.margin + 20;
  }

  addSectionTitle(text: string) {
    this.addPageIfNeeded(40);
    this.doc.setFillColor(COLORS.HEADER_BG);
    this.doc.rect(this.margin, this.y - 18, this.contentWidth, 24, 'F');
    this.doc.setFontSize(FONT_SIZES.H2);
    this.doc.setFont('helvetica', 'bold');
    this.doc.setTextColor(COLORS.HEADER_TEXT);
    this.doc.text(text, this.margin + 5, this.y);
    this.y += 25;
  }

  addSubsectionTitle(text: string) {
      this.addPageIfNeeded(30);
      this.doc.setFontSize(FONT_SIZES.H3);
      this.doc.setFont('helvetica', 'bold');
      this.doc.setTextColor(COLORS.ACCENT_BLUE);
      this.doc.text(text, this.margin, this.y);
      this.y += 18;
  }
  
  addBodyText(text: string | null | undefined) {
    const sanitizedText = String(text || '').replace(/[\u2018\u2019]/g, "'").replace(/[\u201C\u201D]/g, '"').replace(/\u00A0/g, ' ');
    if (!sanitizedText) return;

    this.doc.setFontSize(FONT_SIZES.BODY);
    this.doc.setFont('helvetica', 'normal');
    this.doc.setTextColor(COLORS.PRIMARY_TEXT);
    const lines = this.doc.splitTextToSize(sanitizedText, this.contentWidth);
    this.addPageIfNeeded(lines.length * 12 + 10);
    this.doc.text(lines, this.margin, this.y);
    this.y += lines.length * 12 + 10;
  }

  private addSpacer(height: number) {
    this.addPageIfNeeded(height);
    this.y += height;
  }

  addBulletedList(title: string, items: string[] | undefined, iconPrefix: 'positive' | 'negative' | 'neutral' = 'neutral') {
      if (!items || items.length === 0) return;
      this.addPageIfNeeded(20 + items.length * 15);
      
      const colors = { positive: COLORS.GREEN, negative: COLORS.RED, neutral: COLORS.PRIMARY_TEXT };
      
      this.doc.setFontSize(FONT_SIZES.BODY);
      this.doc.setFont('helvetica', 'bold');
      this.doc.setTextColor(colors[iconPrefix]);
      this.doc.text(title, this.margin, this.y);
      this.y += 15;

      items.forEach(item => {
          this.doc.setFont('helvetica', 'normal');
          this.doc.setTextColor(COLORS.PRIMARY_TEXT);
          const lines = this.doc.splitTextToSize(`• ${item}`, this.contentWidth - 10);
          this.addPageIfNeeded(lines.length * 12);
          this.doc.text(lines, this.margin + 10, this.y);
          this.y += lines.length * 12;
      });
      this.addSpacer(10);
  }
  
  addKeyValueGrid(data: Record<string, string | null | undefined>, columns: number = 3) {
    const entries = Object.entries(data).filter(([, value]) => value);
    if (entries.length === 0) return;

    const boxHeight = 40;
    const boxWidth = this.contentWidth / columns - ((columns - 1) * 7.5 / columns);
    this.addPageIfNeeded(boxHeight + 10);
    
    entries.forEach(([key, value], index) => {
      const x = this.margin + (index % columns) * (boxWidth + 7.5);
      if (index > 0 && index % columns === 0) {
        this.y += boxHeight + 10;
        this.addPageIfNeeded(boxHeight + 10);
      }
      
      this.doc.setDrawColor(COLORS.BORDER_LIGHT);
      this.doc.roundedRect(x, this.y, boxWidth, boxHeight, 3, 3, 'S');

      this.doc.setFontSize(FONT_SIZES.SMALL);
      this.doc.setTextColor(COLORS.SECONDARY_TEXT);
      this.doc.text(key, x + 5, this.y + 12);
      
      this.doc.setFontSize(FONT_SIZES.BODY);
      this.doc.setFont('helvetica', 'bold');
      this.doc.setTextColor(COLORS.PRIMARY_TEXT);
      this.doc.text(String(value || 'N/A'), x + 5, this.y + 28);
    });
    
    this.y += boxHeight + 15;
  }

  addKeyInsightBox(title: string, value: string, color: string, x: number) {
    const boxWidth = this.contentWidth / 4 - 5;
    const boxHeight = 50;
    this.doc.setDrawColor(COLORS.BORDER_LIGHT);
    this.doc.roundedRect(x, this.y, boxWidth, boxHeight, 5, 5, 'S');
    
    this.doc.setFontSize(FONT_SIZES.SMALL);
    this.doc.setTextColor(COLORS.SECONDARY_TEXT);
    this.doc.text(title, x + 10, this.y + 15);
    
    this.doc.setFontSize(FONT_SIZES.H3);
    this.doc.setFont('helvetica', 'bold');
    this.doc.setTextColor(color);
    this.doc.text(value, x + 10, this.y + 35);
  }

  addKeyInsightsGrid(analysisResult: StockAnalysis, currencySymbol: string) {
    this.addPageIfNeeded(70);
    const startX = this.margin;
    const boxWidth = this.contentWidth / 4 - 5;
    
    const st = analysisResult.target_price.short_term;
    const stValue = (st?.low !== null && st?.high !== null) ? `${formatPrice(st.low, currencySymbol)} - ${formatPrice(st.high, currencySymbol)}` : 'N/A';
        
    const lt = analysisResult.target_price.long_term;
    const ltValue = (lt?.low !== null && lt?.high !== null) ? `${formatPrice(lt.low, currencySymbol)} - ${formatPrice(lt.high, currencySymbol)}` : 'N/A';

    const insights = [
        { title: 'Recommendation', value: analysisResult.recommendation, color: COLORS.ACCENT_BLUE },
        { title: 'Short-Term Target', value: stValue, color: COLORS.PRIMARY_TEXT },
        { title: 'Long-Term Target', value: ltValue, color: COLORS.PRIMARY_TEXT },
        { title: 'Stop Loss', value: formatPrice(parseFloat(getMetricValue(analysisResult.stop_loss)), currencySymbol), color: COLORS.RED }
    ];

    insights.forEach((insight, i) => {
        this.addKeyInsightBox(insight.title, insight.value, insight.color, startX + i * (boxWidth + 6.5));
    });
    
    this.y += 70;
  }

  addPriceSummary(analysis: StockAnalysis, currencySymbol: string) {
    this.addPageIfNeeded(40);
    const price = formatPrice(analysis.current_price, currencySymbol);
    const change = analysis.price_change ?? 0;
    const changePercent = analysis.price_change_percentage ?? '';
    const isPositive = change >= 0;
    const changeText = `${isPositive ? '+' : ''}${formatPrice(change, currencySymbol)} (${changePercent})`;

    this.doc.setFontSize(24);
    this.doc.setFont('helvetica', 'bold');
    this.doc.setTextColor(COLORS.PRIMARY_TEXT);
    this.doc.text(price, this.margin, this.y);
    
    this.doc.setFontSize(FONT_SIZES.BODY);
    this.doc.setFont('helvetica', 'normal');
    this.doc.setTextColor(isPositive ? COLORS.GREEN : COLORS.RED);
    this.doc.text(changeText, this.margin, this.y + 15);
    
    this.y += 35;
  }
  
  addRiskAnalysis(riskAnalysis: RiskAnalysis) {
      const { risk_score, risk_level, summary, key_risk_factors } = riskAnalysis;
      const riskColor = risk_score > 75 ? COLORS.RED : risk_score > 50 ? COLORS.ORANGE : risk_score > 25 ? COLORS.YELLOW : COLORS.GREEN;
      
      this.addPageIfNeeded(80);
      
      this.doc.setFontSize(FONT_SIZES.H3);
      this.doc.setTextColor(riskColor);
      this.doc.text(`Risk Score: ${risk_score}/100 (${risk_level})`, this.margin, this.y);
      this.y += 20;
      
      this.addBodyText(summary);
      
      this.addBulletedList('Key Risk Factors:', key_risk_factors, 'negative');
  }
  
  addCompetitiveTable(analysis: CompetitiveAnalysis) {
    const headers = ['METRIC', 'TARGET CO.', ...analysis.competitors.map(c => c.name.toUpperCase()), 'INDUSTRY AVG.'];
    const metrics: (keyof FinancialMetrics)[] = ['pe_ratio', 'pb_ratio', 'debt_to_equity', 'roe'];

    const bodyData = metrics.map(metric => {
        return [
            { content: metric.replace(/_/g, ' ').toUpperCase(), styles: { fontStyle: 'bold' as 'bold' } },
            getMetricValue(analysis.target_company_metrics?.[metric] ?? null),
            ...analysis.competitors.map(c => getMetricValue(c.metrics?.[metric] ?? null)),
            getMetricValue(analysis.industry_average_metrics?.[metric] ?? null),
        ];
    });

    this.addPageIfNeeded(200);

    autoTable(this.doc, {
        head: [headers],
        body: bodyData,
        startY: this.y,
        theme: 'grid',
        styles: { fontSize: FONT_SIZES.SMALL, cellPadding: 4, valign: 'middle' },
        headStyles: { fillColor: COLORS.HEADER_BG, textColor: COLORS.HEADER_TEXT, fontStyle: 'bold' },
        didDrawCell: (data) => {
            if (data.section === 'body' && data.column.index > 0 && data.cell.raw) {
                const rawValue = String(data.cell.raw);
                const allValues = (data.row.raw as (string|{content:string})[]).slice(1).map(v => parseFloat(String(typeof v === 'object' ? v.content : v))).filter(v => !isNaN(v));
                if (allValues.length === 0) return;

                const targetValue = parseFloat(String(data.row.raw[1]));
                const numValue = parseFloat(rawValue);

                if (!isNaN(numValue) && !isNaN(targetValue)) {
                    let barColor = '#d1d5db'; // gray-300
                    const isLowerBetter = ['pe_ratio', 'pb_ratio', 'debt_to_equity'].includes(metrics[data.row.index]);
                    
                    if (isLowerBetter) {
                        if (numValue <= targetValue) barColor = COLORS.GREEN;
                        else if (numValue > targetValue * 1.1) barColor = COLORS.YELLOW;
                    } else { // higher is better (ROE)
                        if (numValue >= targetValue) barColor = COLORS.GREEN;
                        else if (numValue < targetValue * 0.9) barColor = COLORS.YELLOW;
                    }

                    const maxValue = Math.max(...allValues.map(v => Math.abs(v)));
                    if (maxValue > 0) {
                        const barWidth = (Math.abs(numValue) / maxValue) * (data.cell.width - 8);
                        this.doc.setFillColor(barColor);
                        this.doc.rect(data.cell.x + 4, data.cell.y + data.cell.height - 10, barWidth, 6, 'F');
                    }
                }
            }
        },
    });
    
    this.y = (this.doc as any).lastAutoTable.finalY + 20;
  }

  addLeadershipTable(executives: ExecutiveProfile[]) {
    this.addPageIfNeeded(executives.length * 20 + 30);
    autoTable(this.doc, {
        head: [['Name', 'Role', 'Tenure', 'Summary']],
        body: executives.map(e => [e.name, e.role, e.tenure, e.summary]),
        startY: this.y,
        theme: 'striped',
        headStyles: { fillColor: COLORS.HEADER_BG },
    });
    this.y = (this.doc as any).lastAutoTable.finalY + 20;
  }

  addKeyMultiValue(key: string, values: string[], color: string) {
      this.addPageIfNeeded(30 + values.length * 12);
      this.doc.setFontSize(FONT_SIZES.BODY);
      this.doc.setFont('helvetica', 'bold');
      this.doc.setTextColor(COLORS.PRIMARY_TEXT);
      this.doc.text(key, this.margin, this.y);
      this.y += 15;
      
      this.doc.setFont('helvetica', 'normal');
      values.forEach((value, index) => {
          this.doc.setTextColor(index === 1 ? color : COLORS.SECONDARY_TEXT);
          this.doc.text(value, this.margin + 10, this.y);
          this.y += 12;
      });
      this.y += 5;
  }

  addCodeBlock(text: string) {
      this.addPageIfNeeded(40); // Estimate
      this.doc.setFillColor(COLORS.CODE_BG);
      const lines = this.doc.splitTextToSize(text, this.contentWidth - 20);
      const height = lines.length * 10 + 20;
      this.doc.rect(this.margin, this.y, this.contentWidth, height, 'F');
      
      this.doc.setFont('courier', 'normal');
      this.doc.setFontSize(FONT_SIZES.SMALL);
      this.doc.setTextColor(COLORS.RED);
      this.doc.text(lines, this.margin + 10, this.y + 15);
      this.y += height + 10;
  }

  addLink(text: string, url: string) {
      this.addPageIfNeeded(20);
      this.doc.setFontSize(FONT_SIZES.BODY);
      this.doc.setTextColor(COLORS.ACCENT_BLUE);
      this.doc.textWithLink(text, this.margin, this.y, { url });
      this.y += 15;
  }
  
  addExecutiveSummaries(
    analyses: { title: string; summary: string | null | undefined }[]
  ) {
    const validSummaries = analyses.filter(a => a.summary && a.summary !== 'N/A');
    if (validSummaries.length === 0) return;

    this.addSectionTitle('Agent Executive Summaries');
    
    validSummaries.forEach(item => {
        this.addSubsectionTitle(item.title);
        this.addBodyText(item.summary);
    });

    this.addSpacer(10);
  }

  save(filename: string) {
    this.addHeadersAndFooters();
    this.doc.save(filename);
  }
}

export async function generateAnalysisPdf(
  analysisResult: StockAnalysis,
  esgAnalysis: EsgAnalysis | null,
  macroAnalysis: MacroAnalysis | null,
  marketIntelligenceAnalysis: MarketIntelligenceAnalysis | null,
  leadershipAnalysis: LeadershipAnalysis | null,
  competitiveAnalysis: CompetitiveAnalysis | null,
  sectorAnalysis: SectorAnalysis | null,
  corporateCalendarAnalysis: CorporateCalendarAnalysis | null,
  technicalAnalysis: TechnicalAnalysis | null,
  contrarianAnalysis: ContrarianAnalysis | null,
  quantitativeAnalysis: QuantitativeAnalysis | null,
  currencySymbol: string,
) {
    const title = `Financial Analysis Report: ${analysisResult.share_name} (${analysisResult.stock_symbol})`;
    const builder = new PdfBuilder(title);

    builder.buildTitlePage(
        `${analysisResult.share_name} (${analysisResult.stock_symbol})`,
        'AI-Generated Financial Analysis Report'
    );
    
    builder.addExecutiveSummaries([
        { title: 'Quantitative Forecast', summary: quantitativeAnalysis?.summary },
        { title: 'Competitive Landscape', summary: competitiveAnalysis?.competitive_summary },
        { title: 'Leadership & Governance', summary: leadershipAnalysis?.summary },
        { title: 'Market Intelligence', summary: marketIntelligenceAnalysis?.intelligence_summary },
        { title: 'ESG Profile', summary: esgAnalysis?.justification.overall_summary },
        { title: 'Macroeconomic Context', summary: macroAnalysis?.outlook_summary },
        { title: 'Contrarian Analysis (Bear Case)', summary: contrarianAnalysis?.bear_case_summary },
        { title: 'Technical Analysis', summary: technicalAnalysis?.summary },
    ]);
    
    builder.addSectionTitle('Overall Recommendation & Thesis');
    builder.addPriceSummary(analysisResult, currencySymbol);
    builder.addKeyInsightsGrid(analysisResult, currencySymbol);
    builder.addSubsectionTitle('Overall Recommendation');
    builder.addBodyText(analysisResult.justification.overall_recommendation);
    if (analysisResult.risk_analysis) {
        builder.addSubsectionTitle('Risk Overview');
        builder.addRiskAnalysis(analysisResult.risk_analysis);
    }

    if (quantitativeAnalysis) {
        builder.addSectionTitle('Quantitative Forecast (30-Day)');
        const { forecast, summary, key_drivers } = quantitativeAnalysis;
        const target = formatPrice(forecast.price_target, currencySymbol);
        const interval = `(${formatPrice(forecast.confidence_interval[0], currencySymbol)} - ${formatPrice(forecast.confidence_interval[1], currencySymbol)})`;
        builder.addKeyValueGrid({
            'Price Target': target,
            'Confidence Interval': interval
        }, 2);
        builder.addBodyText(summary);
        builder.addBodyText(forecast.rationale);

        const driversText = key_drivers.map(d => `${d.feature} (${d.weight} ${d.impact})`);
        builder.addBulletedList('Key Model Drivers:', driversText);
    }

    if (competitiveAnalysis) {
        builder.addSectionTitle('Competitive Landscape');
        builder.addBodyText(competitiveAnalysis.competitive_summary);
        builder.addCompetitiveTable(competitiveAnalysis);
    }
    
    if (leadershipAnalysis) {
        builder.addSectionTitle('Leadership & Governance');
        builder.addBodyText(leadershipAnalysis.summary);
        if (leadershipAnalysis.key_executives.length > 0) {
             builder.addLeadershipTable(leadershipAnalysis.key_executives);
        }
    }
    
    if (marketIntelligenceAnalysis) {
        builder.addSectionTitle('Market Intelligence');
        builder.addBodyText(marketIntelligenceAnalysis.intelligence_summary);
        builder.addBulletedList('Key Positive Points:', marketIntelligenceAnalysis.key_positive_points, 'positive');
        builder.addBulletedList('Key Negative Points:', marketIntelligenceAnalysis.key_negative_points, 'negative');
    }
    
    if (esgAnalysis) {
        builder.addSectionTitle('ESG Profile');
        builder.addKeyValueGrid({
            'ESG Score': esgAnalysis.score,
            'Momentum (24m)': esgAnalysis.esg_momentum,
            'Confidence': esgAnalysis.score_confidence || 'N/A',
        }, 3);
        builder.addBodyText(esgAnalysis.justification.overall_summary);
    }
    
    if (macroAnalysis) {
        builder.addSectionTitle('Macroeconomic Context');
        builder.addKeyValueGrid({
            'GDP Growth': macroAnalysis.gdp_growth,
            'Inflation Rate': macroAnalysis.inflation_rate,
            'Interest Rate': macroAnalysis.interest_rate,
        }, 3);
        builder.addBodyText(macroAnalysis.outlook_summary);
        builder.addSubsectionTitle('Sector Impact');
        builder.addBodyText(macroAnalysis.sector_impact);
    }

    if (contrarianAnalysis) {
        builder.addSectionTitle('Contrarian Analysis (Bear Case)');
        builder.addBodyText(contrarianAnalysis.bear_case_summary);
        builder.addBulletedList('Key Contrarian Points:', contrarianAnalysis.key_contrarian_points, 'negative');
    }
    
    if (technicalAnalysis) {
        builder.addSectionTitle('Technical Analysis');
        builder.addBodyText(technicalAnalysis.summary);
        builder.addKeyValueGrid({
            'Trend': technicalAnalysis.trend,
            'Support Level': technicalAnalysis.support_level,
            'Resistance Level': technicalAnalysis.resistance_level,
        }, 3);
        builder.addSubsectionTitle('Moving Averages');
        builder.addBodyText(technicalAnalysis.moving_averages_summary);
        builder.addSubsectionTitle('Indicators (RSI, MACD)');
        builder.addBodyText(technicalAnalysis.indicators_summary);
    }

    if (analysisResult.disclosures) {
        builder.addSectionTitle('Disclosures');
        builder.addSubsectionTitle('Disclaimer');
        builder.addBodyText(analysisResult.disclosures.disclaimer);
        builder.addSubsectionTitle('Limitations');
        builder.addBodyText(analysisResult.disclosures.limitations);
    }

    const filename = `AI_Analysis_${analysisResult.stock_symbol}_${getFilenameTimestamp()}.pdf`;
    builder.save(filename);
}

export async function generateMethodologyPdf(
  stockSymbol: string,
  plan: string | null,
  steps: ExecutionStep[],
  consolidatedSources: GroundingSource[]
) {
    const title = `Methodology Report: ${stockSymbol}`;
    const builder = new PdfBuilder(title);

    builder.buildTitlePage(
        `AI Execution Methodology for ${stockSymbol}`,
        'A transparent log of the analysis process.'
    );

    if (plan) {
        builder.addSectionTitle('Analysis Plan');
        builder.addBodyText(plan);
    }
    
    if (steps.length > 0) {
        builder.addSectionTitle('Execution Log');
        steps.forEach(step => {
            const statusColor = step.status === 'complete' ? COLORS.GREEN : step.status === 'error' ? COLORS.RED : COLORS.SECONDARY_TEXT;
            builder.addKeyMultiValue(
                step.stepName,
                [`Agent: ${step.agentKey.toUpperCase()}`, `Status: ${step.status.toUpperCase()}`],
                statusColor
            );
            if (step.output && step.status === 'error') {
                 builder.addCodeBlock(`Error: ${step.output}`);
            }
        });
    }

    if (consolidatedSources.length > 0) {
        builder.addSectionTitle('Consolidated Sources');
        consolidatedSources.forEach(source => {
            builder.addLink(source.title || source.uri, source.uri);
        });
    }

    const filename = `AI_Methodology_${stockSymbol}_${getFilenameTimestamp()}.pdf`;
    builder.save(filename);
}